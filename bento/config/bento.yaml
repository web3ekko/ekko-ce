http:
  enabled: true
  address: 0.0.0.0:4195

input:
  websocket:
    url: ${AVAX_C_WEBSOCKET_URL}
    payload: |
      {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "eth_subscribe",
        "params": ["newHeads"]
      }

buffer:
  memory:
    limit: 10_000_000 # 10MB

pipeline:
  processors:
    # First attempt to decode with cached ABI
    - decode_tx:
        redis_url: ${REDIS_URL}

    # Handle ABI misses
    - catch:
        pattern: "ABI_MISS"
        processors:
          # Fetch ABI from Snowtrace
          - http:
              url: https://api.snowtrace.io/api?module=contract&action=getabi&address=${!meta("contract_addr")}
              verb: GET
              rate_limit: 5-S
              retry_period: 1s
              max_retry_backoff: 300s
              backoff_on:
                - 429  # Rate limit
                - 5XX  # Server errors
              drop_on:
                - 404  # Contract not found
              successful_on: [ 200 ]

          # Parse response and extract ABI
          - bloblang: |
              root = match {
                this.status == "1" -> {
                  "contract_address": meta("contract_addr"),
                  "abi": this.result,
                  "timestamp": now()
                }
              }

          # Store ABI in Redis (no TTL)
          - redis:
              url: ${REDIS_URL}
              command: set
              key: ${!json("contract_address")}
              value: ${!json("abi")}

          # Store versioned copy in MinIO
          - aws_s3:
              bucket: abi
              endpoint: ${MINIO_ENDPOINT}
              credentials:
                id: ${MINIO_ACCESS_KEY}
                secret: ${MINIO_SECRET_KEY}
              region: us-east-1
              path: abi/${!json("contract_address")}/${!json("timestamp")}.json
              force_path_style_urls: true

          # Build template map
          - bloblang: |
              let abi = json("abi")
              let global_templates = @global_templates.load()
              let functions = $abi.functions()
              
              root = {
                "contract_address": json("contract_address"),
                "templates": $functions.map_each(func(sig) -> {
                  let template = $global_templates.get(sig)
                  if template {
                    template
                  } else {
                    "Called " + sig + " with args " + range(0, $sig.args().length()).map_each(i -> "{" + i + "}").join(", ")
                  }
                })
              }

          # Store template map in Redis
          - redis:
              url: ${REDIS_URL}
              command: hset
              key: tmpl:${!json("contract_address")}
              values: ${!json("templates")}

          # Store template map in MinIO
          - aws_s3:
              bucket: abi-templates
              endpoint: ${MINIO_ENDPOINT}
              credentials:
                id: ${MINIO_ACCESS_KEY}
                secret: ${MINIO_SECRET_KEY}
              region: us-east-1
              path: abi-templates/${!json("contract_address")}/${!json("timestamp")}.json
              force_path_style_urls: true

          # Retry decode with fresh cache
          - decode_tx:
              redis_url: ${REDIS_URL}

    # Output to Redis PubSub
    - redis_pubsub:
        url: ${REDIS_URL}
        channel: tx_plain_english

resources:
  caches:
    redis_abi:
      redis:
        url: ${REDIS_URL}
        prefix: abi:
    redis_templates:
      redis:
        url: ${REDIS_URL}
        prefix: tmpl:

  files:
    global_templates:
      path: /app/templates.json

metrics:
  prometheus:
    prefix: benthos_
    push_url: ""
    push_interval: ""

tracer:
  jaeger:
    agent_address: ""
    collector_url: ""
    service_name: benthos
