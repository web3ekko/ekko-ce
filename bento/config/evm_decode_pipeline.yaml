# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
# â”ƒ   Benthos v4 pipeline â€“ EVM transaction fast decoder     â”ƒ
# â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
#   INPUT  :  chain.${CHAIN_ID}.tx   (raw tx JSON)
#   OUTPUT :  chain.${CHAIN_ID}.log  (tx + decoded_call map)
#   CACHE  :  Valkey (Redis-compatible) for selector and ABI
#   ENV    :  PULSAR_URL, CHAIN_ID, SNOWTRACE_KEY, VALKEY_ADDR
#
#  A quick visual:
#        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   RPC âœâ”‚ tx-ingestor  â”‚ğŸ¡’ğŸ¡’ğŸ¡’â”‚ chain.<id>.tx â”‚ â”€â–¶ â‘  lift_meta
#        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#                                             â–¼
#                                            â‘¡ fast_selector_lookup
#                                             â–¼
#                   (hit)â”€â”€â”€â”€â”€â”€â–¶ â‘£ evm_decode_fast.so
#                    â”‚
#                    â”‚miss
#                    â–¼
#            â‘¢ selector_or_abi_resolver
#                    â”‚
#                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ back to â‘¡ (now itâ€™s a hit)
#
#  Each numbered box below is an independent processor.
#
#--------------------------------------------------------------#
input:
  pulsar:
    url: ${PULSAR_URL}
    topics: [ "chain.${CHAIN_ID}.tx" ]
    subscription_name: tx-decoder
    subscription_type: shared

#--------------------------------------------------------------#
pipeline:
  processors:

  # â‘   LIFT METADATA ---------------------------------------------------------
  - label: lift_meta
    bloblang: |
      # Stash the parts of the tx we use multiple times as metadata keys so
      # later processors can access them without reparsing the JSON.
      meta "chain_id" = "${CHAIN_ID}"
      meta "to_addr"  = this.to
      meta "tx_hash"  = this.hash
      meta "selector" = this.input.or("")[:10]  # 0x + 4-byte func selector
      root = this                                 # keep body unchanged

  # â‘¡  FAST SELECTOR LOOK-UP -------------------------------------------------
  - label: fast_selector_lookup           # tries two keys, no branching yet
    branch:
      processors:
        - cache:                        # addr-scoped key (handles overloads)
            resource: valkey
            action: get
            key: |
              sel:${!meta("chain_id")}:
              ${!meta("to_addr").lowercase()}:
              ${!meta("selector")}
        - catch:                        # global key (ERC-20 â€˜transferâ€™, etc.)
            - cache:
                resource: valkey
                action: get
                key: sel:${!meta("chain_id")}:${!meta("selector")}
      result_map: |
        meta "sig_json" = content()      # "" when miss
        root = this

  # â‘¢  SELECTOR OR ABI RESOLVER  (only fires on miss) ------------------------
  - label: selector_or_abi_resolver
    condition:
      bloblang: meta("sig_json") == ""
    processors:
      # 3a.  Try full ABI in cache
      - cache:
          resource: valkey
          action: get
          key: abi:${!meta("chain_id")}:${!meta("to_addr").lowercase()}
      # 3b.  If still miss, hit SnowTrace, then write ABI to cache
      - catch:
          - http:
              url: |
                https://api.snowtrace.io/api
                ?module=contract
                &action=getabi
                &address=${!meta("to_addr")}
              verb: GET
              extract: result
          - cache:
              resource: valkey
              action: set
              key: abi:${!meta("chain_id")}:${!meta("to_addr").lowercase()}
              value: ${!content()}
              ttl: 24h
      # 3c.  From the ABI, explode every function into selector JSON blobs
      - bloblang: |
          # Parse the ABI JSON string we just fetched
          root = json_parse(content())
          root = match root {
            this is array => this
            _             => []
          }
          # Build a map: selector â†’ {name,inputs}
          map selector_map = {}
          root.map_each(fun -> {
            if fun.type == "function" {
              let sig = sha3(fun.name + "(" + fun.inputs.map_each(inp -> inp.type).join(",") + ")")
              let sel = "0x" + sig.slice(0,8)
              selector_map[sel] = {
                "name": fun.name,
                "inputs": fun.inputs,
                "selector": sel
              }
            }
          })
          root = selector_map
      # 3d.  Store each entry in selector cache (âˆ TTL)
      - for_each_map_each:
          processors:
            - cache:
                resource: valkey
                action: set
                key: sel:${!meta("chain_id")}:${!json_key()}
                value: ${!json_value()}
                ttl: 0
            # also address-scoped for overload safety
            - cache:
                resource: valkey
                action: set
                key: |
                  sel:${!meta("chain_id")}:
                  ${!meta("to_addr").lowercase()}:
                  ${!json_key()}
                value: ${!json_value()}
                ttl: 0
      # 3e.  fetch the selector json that triggered the miss (guaranteed hit now)
      - cache:
          resource: valkey
          action: get
          key: sel:${!meta("chain_id")}:${!meta("selector")}
      - bloblang: meta "sig_json" = content()

  # â‘£  FUNCTION-CALL DECODER (Go plugin) ------------------------------------
  - label: decode_call
    run: /bento/plugins/evm_decode_fast.so

#--------------------------------------------------------------#
output:
  pulsar:
    url: ${PULSAR_URL}
    topic: chain.${CHAIN_ID}.log

#--------------------------------------------------------------#
#                 SHARED EXTERNAL RESOURCES
#--------------------------------------------------------------#
resources:
  caches:
    - label: valkey
      redis:
        url: redis://${VALKEY_ADDR}/0
