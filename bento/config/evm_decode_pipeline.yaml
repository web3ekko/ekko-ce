# ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
# ┃   Benthos v4 pipeline – EVM transaction fast decoder     ┃
# ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
#   INPUT  :  chain.${CHAIN_ID}.tx   (raw tx JSON)
#   OUTPUT :  chain.${CHAIN_ID}.log  (tx + decoded_call map)
#   CACHE  :  Valkey (Redis-compatible) for selector and ABI
#   ENV    :  PULSAR_URL, CHAIN_ID, SNOWTRACE_KEY, VALKEY_ADDR
#
#  A quick visual:
#        ┌──────────────┐      ┌───────────────┐
#   RPC ➜│ tx-ingestor  │🡒🡒🡒│ chain.<id>.tx │ ─▶ ① lift_meta
#        └──────────────┘      └───────────────┘
#                                             ▼
#                                            ② fast_selector_lookup
#                                             ▼
#                   (hit)──────▶ ④ evm_decode_fast.so
#                    │
#                    │miss
#                    ▼
#            ③ selector_or_abi_resolver
#                    │
#                    └───────────▶ back to ② (now it’s a hit)
#
#  Each numbered box below is an independent processor.
#
#--------------------------------------------------------------#
input:
  pulsar:
    url: ${PULSAR_URL}
    topics: [ "chain.${CHAIN_ID}.tx" ]
    subscription_name: tx-decoder
    subscription_type: shared

#--------------------------------------------------------------#
pipeline:
  processors:

  # ①  LIFT METADATA ---------------------------------------------------------
  - label: lift_meta
    bloblang: |
      # Stash the parts of the tx we use multiple times as metadata keys so
      # later processors can access them without reparsing the JSON.
      meta "chain_id" = "${CHAIN_ID}"
      meta "to_addr"  = this.to
      meta "tx_hash"  = this.hash
      meta "selector" = this.input.or("")[:10]  # 0x + 4-byte func selector
      root = this                                 # keep body unchanged

  # ②  FAST SELECTOR LOOK-UP -------------------------------------------------
  - label: fast_selector_lookup           # tries two keys, no branching yet
    branch:
      processors:
        - cache:                        # addr-scoped key (handles overloads)
            resource: valkey
            action: get
            key: |
              sel:${!meta("chain_id")}:
              ${!meta("to_addr").lowercase()}:
              ${!meta("selector")}
        - catch:                        # global key (ERC-20 ‘transfer’, etc.)
            - cache:
                resource: valkey
                action: get
                key: sel:${!meta("chain_id")}:${!meta("selector")}
      result_map: |
        meta "sig_json" = content()      # "" when miss
        root = this

  # ③  SELECTOR OR ABI RESOLVER  (only fires on miss) ------------------------
  - label: selector_or_abi_resolver
    condition:
      bloblang: meta("sig_json") == ""
    processors:
      # 3a.  Try full ABI in cache
      - cache:
          resource: valkey
          action: get
          key: abi:${!meta("chain_id")}:${!meta("to_addr").lowercase()}
      # 3b.  If still miss, hit SnowTrace, then write ABI to cache
      - catch:
          - http:
              url: |
                https://api.snowtrace.io/api
                ?module=contract
                &action=getabi
                &address=${!meta("to_addr")}
              verb: GET
              extract: result
          - cache:
              resource: valkey
              action: set
              key: abi:${!meta("chain_id")}:${!meta("to_addr").lowercase()}
              value: ${!content()}
              ttl: 24h
      # 3c.  From the ABI, explode every function into selector JSON blobs
      - bloblang: |
          # Parse the ABI JSON string we just fetched
          root = json_parse(content())
          root = match root {
            this is array => this
            _             => []
          }
          # Build a map: selector → {name,inputs}
          map selector_map = {}
          root.map_each(fun -> {
            if fun.type == "function" {
              let sig = sha3(fun.name + "(" + fun.inputs.map_each(inp -> inp.type).join(",") + ")")
              let sel = "0x" + sig.slice(0,8)
              selector_map[sel] = {
                "name": fun.name,
                "inputs": fun.inputs,
                "selector": sel
              }
            }
          })
          root = selector_map
      # 3d.  Store each entry in selector cache (∞ TTL)
      - for_each_map_each:
          processors:
            - cache:
                resource: valkey
                action: set
                key: sel:${!meta("chain_id")}:${!json_key()}
                value: ${!json_value()}
                ttl: 0
            # also address-scoped for overload safety
            - cache:
                resource: valkey
                action: set
                key: |
                  sel:${!meta("chain_id")}:
                  ${!meta("to_addr").lowercase()}:
                  ${!json_key()}
                value: ${!json_value()}
                ttl: 0
      # 3e.  fetch the selector json that triggered the miss (guaranteed hit now)
      - cache:
          resource: valkey
          action: get
          key: sel:${!meta("chain_id")}:${!meta("selector")}
      - bloblang: meta "sig_json" = content()

  # ④  FUNCTION-CALL DECODER (Go plugin) ------------------------------------
  - label: decode_call
    run: /bento/plugins/evm_decode_fast.so

#--------------------------------------------------------------#
output:
  pulsar:
    url: ${PULSAR_URL}
    topic: chain.${CHAIN_ID}.log

#--------------------------------------------------------------#
#                 SHARED EXTERNAL RESOURCES
#--------------------------------------------------------------#
resources:
  caches:
    - label: valkey
      redis:
        url: redis://${VALKEY_ADDR}/0
