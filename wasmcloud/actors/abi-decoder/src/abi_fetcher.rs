//! # ABI Fetcher Module
//!
//! HTTP client for fetching contract ABIs from external sources (Etherscan, Sourcify).
//! Uses WASI HTTP for making HTTP requests in the wasmCloud environment.

use serde::{Deserialize, Serialize};

// Import WASI types from the crate root (generated by wit_bindgen in lib.rs)
use crate::wasi;

/// Error types for ABI fetching operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FetchError {
    /// Network not supported for ABI fetching
    UnsupportedNetwork { network: String, subnet: String },
    /// HTTP request failed
    HttpError { message: String },
    /// API rate limit exceeded
    RateLimited { retry_after: Option<u64> },
    /// Contract not verified/found
    ContractNotVerified { address: String },
    /// Failed to parse API response
    ParseError { message: String },
    /// URL parsing error
    UrlParseError { url: String, message: String },
}

impl std::fmt::Display for FetchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FetchError::UnsupportedNetwork { network, subnet } => {
                write!(f, "Unsupported network: {}/{}", network, subnet)
            }
            FetchError::HttpError { message } => {
                write!(f, "HTTP error: {}", message)
            }
            FetchError::RateLimited { retry_after } => {
                write!(f, "Rate limited, retry after: {:?}s", retry_after)
            }
            FetchError::ContractNotVerified { address } => {
                write!(f, "Contract not verified: {}", address)
            }
            FetchError::ParseError { message } => {
                write!(f, "Parse error: {}", message)
            }
            FetchError::UrlParseError { url, message } => {
                write!(f, "URL parse error for {}: {}", url, message)
            }
        }
    }
}

impl std::error::Error for FetchError {}

/// Etherscan API response structure
#[derive(Debug, Deserialize)]
struct EtherscanResponse {
    status: String,
    message: String,
    result: serde_json::Value,
}

/// ABI source information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FetchedAbi {
    /// The ABI JSON string
    pub abi_json: String,
    /// Source of the ABI (e.g., "etherscan", "sourcify")
    pub source: String,
    /// Whether the contract is verified
    pub verified: bool,
}

/// Get Etherscan-compatible API URL for a given network
pub fn get_etherscan_url(network: &str, subnet: &str) -> Option<String> {
    match (network.to_lowercase().as_str(), subnet.to_lowercase().as_str()) {
        // Ethereum
        ("ethereum", "mainnet") => Some("https://api.etherscan.io/api".to_string()),
        ("ethereum", "sepolia") => Some("https://api-sepolia.etherscan.io/api".to_string()),
        ("ethereum", "goerli") => Some("https://api-goerli.etherscan.io/api".to_string()),

        // Polygon
        ("polygon", "mainnet") => Some("https://api.polygonscan.com/api".to_string()),
        ("polygon", "amoy") => Some("https://api-amoy.polygonscan.com/api".to_string()),

        // Arbitrum
        ("arbitrum", "mainnet") => Some("https://api.arbiscan.io/api".to_string()),
        ("arbitrum", "sepolia") => Some("https://api-sepolia.arbiscan.io/api".to_string()),

        // Optimism
        ("optimism", "mainnet") => Some("https://api-optimistic.etherscan.io/api".to_string()),
        ("optimism", "sepolia") => Some("https://api-sepolia-optimistic.etherscan.io/api".to_string()),

        // Base
        ("base", "mainnet") => Some("https://api.basescan.org/api".to_string()),
        ("base", "sepolia") => Some("https://api-sepolia.basescan.org/api".to_string()),

        // Avalanche
        ("avalanche", "mainnet") => Some("https://api.snowtrace.io/api".to_string()),
        ("avalanche", "fuji") => Some("https://api-testnet.snowtrace.io/api".to_string()),

        // BNB Smart Chain
        ("bsc", "mainnet") => Some("https://api.bscscan.com/api".to_string()),
        ("bsc", "testnet") => Some("https://api-testnet.bscscan.com/api".to_string()),

        // Fantom
        ("fantom", "mainnet") => Some("https://api.ftmscan.com/api".to_string()),

        // zkSync Era
        ("zksync", "mainnet") => Some("https://block-explorer-api.mainnet.zksync.io/api".to_string()),

        _ => None,
    }
}

/// Get Sourcify API URL for a given network
pub fn get_sourcify_chain_id(network: &str, subnet: &str) -> Option<&'static str> {
    match (network.to_lowercase().as_str(), subnet.to_lowercase().as_str()) {
        // Ethereum
        ("ethereum", "mainnet") => Some("1"),
        ("ethereum", "sepolia") => Some("11155111"),
        ("ethereum", "goerli") => Some("5"),

        // Polygon
        ("polygon", "mainnet") => Some("137"),
        ("polygon", "amoy") => Some("80002"),

        // Arbitrum
        ("arbitrum", "mainnet") => Some("42161"),
        ("arbitrum", "sepolia") => Some("421614"),

        // Optimism
        ("optimism", "mainnet") => Some("10"),
        ("optimism", "sepolia") => Some("11155420"),

        // Base
        ("base", "mainnet") => Some("8453"),
        ("base", "sepolia") => Some("84532"),

        // Avalanche
        ("avalanche", "mainnet") => Some("43114"),
        ("avalanche", "fuji") => Some("43113"),

        // BNB Smart Chain
        ("bsc", "mainnet") => Some("56"),
        ("bsc", "testnet") => Some("97"),

        // Fantom
        ("fantom", "mainnet") => Some("250"),

        // zkSync Era
        ("zksync", "mainnet") => Some("324"),

        _ => None,
    }
}

/// Parse URL into components for WASI HTTP request
fn parse_url(url: &str) -> Result<(wasi::http::types::Scheme, String, String), FetchError> {
    // Parse scheme
    let (scheme_str, rest) = url.split_once("://")
        .ok_or_else(|| FetchError::UrlParseError {
            url: url.to_string(),
            message: "Invalid URL format - missing scheme".to_string(),
        })?;

    let scheme = match scheme_str {
        "http" => wasi::http::types::Scheme::Http,
        "https" => wasi::http::types::Scheme::Https,
        _ => return Err(FetchError::UrlParseError {
            url: url.to_string(),
            message: format!("Unsupported scheme: {}", scheme_str),
        }),
    };

    // Parse authority (host[:port]) and path
    let (authority, path) = if let Some((auth, p)) = rest.split_once('/') {
        (auth.to_string(), format!("/{}", p))
    } else {
        (rest.to_string(), "/".to_string())
    };

    Ok((scheme, authority, path))
}

/// Make an HTTP GET request using WASI HTTP
fn http_get(url: &str) -> Result<Vec<u8>, FetchError> {
    eprintln!("[ABI-FETCHER] Making HTTP GET request to: {}", url);

    // Parse the URL
    let (scheme, authority, path) = parse_url(url)?;

    // Create HTTP headers
    let headers = wasi::http::types::Fields::new();
    headers.set(&"accept".to_string(), &vec!["application/json".as_bytes().to_vec()])
        .map_err(|e| FetchError::HttpError {
            message: format!("Failed to set accept header: {:?}", e),
        })?;
    headers.set(&"user-agent".to_string(), &vec!["ekko-abi-decoder/1.0".as_bytes().to_vec()])
        .map_err(|e| FetchError::HttpError {
            message: format!("Failed to set user-agent header: {:?}", e),
        })?;

    // Create outgoing HTTP request
    let request = wasi::http::types::OutgoingRequest::new(headers);

    // Set request properties - GET method
    request.set_method(&wasi::http::types::Method::Get)
        .map_err(|_| FetchError::HttpError {
            message: "Failed to set request method".to_string(),
        })?;
    request.set_scheme(Some(&scheme))
        .map_err(|_| FetchError::HttpError {
            message: "Failed to set request scheme".to_string(),
        })?;
    request.set_authority(Some(&authority))
        .map_err(|_| FetchError::HttpError {
            message: "Failed to set request authority".to_string(),
        })?;
    request.set_path_with_query(Some(&path))
        .map_err(|_| FetchError::HttpError {
            message: "Failed to set request path".to_string(),
        })?;

    // Send the HTTP request
    let future_response = wasi::http::outgoing_handler::handle(request, None)
        .map_err(|e| FetchError::HttpError {
            message: format!("Failed to send HTTP request: {:?}", e),
        })?;

    // Wait for the response by polling
    let pollable = future_response.subscribe();
    wasi::io::poll::poll(&[&pollable]);

    // Get the response
    let outer_result = future_response.get()
        .ok_or_else(|| FetchError::HttpError {
            message: "Failed to get response from future".to_string(),
        })?;

    let inner_result = outer_result
        .map_err(|e| FetchError::HttpError {
            message: format!("HTTP request failed (outer): {:?}", e),
        })?;

    let incoming_response = inner_result
        .map_err(|e| FetchError::HttpError {
            message: format!("HTTP request failed (inner): {:?}", e),
        })?;

    // Check response status
    let status = incoming_response.status();
    eprintln!("[ABI-FETCHER] Response status: {}", status);

    if status == 429 {
        return Err(FetchError::RateLimited { retry_after: None });
    }

    if status < 200 || status >= 300 {
        return Err(FetchError::HttpError {
            message: format!("HTTP error: status {}", status),
        });
    }

    // Read response body
    let response_body = incoming_response.consume()
        .map_err(|_| FetchError::HttpError {
            message: "Failed to consume response body".to_string(),
        })?;

    let input_stream = response_body.stream()
        .map_err(|_| FetchError::HttpError {
            message: "Failed to get response stream".to_string(),
        })?;

    let mut response_bytes = Vec::new();
    loop {
        match input_stream.blocking_read(8192) {
            Ok(chunk) => {
                if chunk.is_empty() {
                    break;
                }
                response_bytes.extend_from_slice(&chunk);
            }
            Err(_) => {
                break;
            }
        }
    }

    eprintln!("[ABI-FETCHER] Response size: {} bytes", response_bytes.len());
    Ok(response_bytes)
}

/// Fetch ABI from Etherscan-compatible API
pub fn fetch_abi_etherscan(
    contract_address: &str,
    network: &str,
    subnet: &str,
    api_key: Option<&str>,
) -> Result<FetchedAbi, FetchError> {
    let base_url = get_etherscan_url(network, subnet)
        .ok_or_else(|| FetchError::UnsupportedNetwork {
            network: network.to_string(),
            subnet: subnet.to_string(),
        })?;

    // Build the API URL
    let mut url = format!(
        "{}?module=contract&action=getabi&address={}",
        base_url,
        contract_address
    );

    // Add API key if provided
    if let Some(key) = api_key {
        url.push_str(&format!("&apikey={}", key));
    }

    eprintln!("[ABI-FETCHER] Fetching ABI from Etherscan for {} on {}/{}",
        contract_address, network, subnet);

    // Make the HTTP request
    let response_bytes = http_get(&url)?;

    // Parse the response
    let response: EtherscanResponse = serde_json::from_slice(&response_bytes)
        .map_err(|e| FetchError::ParseError {
            message: format!("Failed to parse Etherscan response: {}", e),
        })?;

    // Check for errors
    if response.status != "1" {
        // Handle specific error cases
        let result_str = response.result.as_str().unwrap_or("");
        if result_str.contains("not verified") || result_str.contains("not found") {
            return Err(FetchError::ContractNotVerified {
                address: contract_address.to_string(),
            });
        }
        if result_str.contains("rate limit") || response.message.contains("rate limit") {
            return Err(FetchError::RateLimited { retry_after: None });
        }
        return Err(FetchError::HttpError {
            message: format!("Etherscan error: {} - {}", response.message, result_str),
        });
    }

    // The result should be the ABI JSON string
    let abi_json = match &response.result {
        serde_json::Value::String(s) => s.clone(),
        _ => return Err(FetchError::ParseError {
            message: "Expected ABI string in result".to_string(),
        }),
    };

    // Validate it's valid JSON
    serde_json::from_str::<serde_json::Value>(&abi_json)
        .map_err(|e| FetchError::ParseError {
            message: format!("Invalid ABI JSON: {}", e),
        })?;

    eprintln!("[ABI-FETCHER] Successfully fetched ABI from Etherscan");

    Ok(FetchedAbi {
        abi_json,
        source: format!("etherscan:{}/{}", network, subnet),
        verified: true,
    })
}

/// Fetch ABI from Sourcify
pub fn fetch_abi_sourcify(
    contract_address: &str,
    network: &str,
    subnet: &str,
) -> Result<FetchedAbi, FetchError> {
    let chain_id = get_sourcify_chain_id(network, subnet)
        .ok_or_else(|| FetchError::UnsupportedNetwork {
            network: network.to_string(),
            subnet: subnet.to_string(),
        })?;

    // Sourcify API endpoints
    // First try full match, then partial match
    let endpoints = [
        format!(
            "https://sourcify.dev/server/files/{}/{}",
            chain_id, contract_address
        ),
        format!(
            "https://sourcify.dev/server/files/any/{}/{}",
            chain_id, contract_address
        ),
    ];

    eprintln!("[ABI-FETCHER] Fetching ABI from Sourcify for {} on chain {}",
        contract_address, chain_id);

    for endpoint in &endpoints {
        match http_get(endpoint) {
            Ok(response_bytes) => {
                // Sourcify returns file list, we need to find the ABI file
                let files: Vec<serde_json::Value> = serde_json::from_slice(&response_bytes)
                    .map_err(|e| FetchError::ParseError {
                        message: format!("Failed to parse Sourcify response: {}", e),
                    })?;

                // Look for metadata.json or the ABI directly
                for file in &files {
                    if let Some(name) = file.get("name").and_then(|n| n.as_str()) {
                        if name.ends_with("metadata.json") {
                            if let Some(content) = file.get("content").and_then(|c| c.as_str()) {
                                // Parse metadata and extract ABI
                                let metadata: serde_json::Value = serde_json::from_str(content)
                                    .map_err(|e| FetchError::ParseError {
                                        message: format!("Failed to parse metadata: {}", e),
                                    })?;

                                if let Some(abi) = metadata.get("output").and_then(|o| o.get("abi")) {
                                    let abi_json = serde_json::to_string(abi)
                                        .map_err(|e| FetchError::ParseError {
                                            message: format!("Failed to serialize ABI: {}", e),
                                        })?;

                                    eprintln!("[ABI-FETCHER] Successfully fetched ABI from Sourcify");

                                    return Ok(FetchedAbi {
                                        abi_json,
                                        source: format!("sourcify:{}", chain_id),
                                        verified: true,
                                    });
                                }
                            }
                        }
                    }
                }
            }
            Err(FetchError::HttpError { message }) if message.contains("404") => {
                // Try next endpoint
                continue;
            }
            Err(e) => return Err(e),
        }
    }

    Err(FetchError::ContractNotVerified {
        address: contract_address.to_string(),
    })
}

/// Fetch ABI from any available source (tries Etherscan first, then Sourcify)
pub fn fetch_abi(
    contract_address: &str,
    network: &str,
    subnet: &str,
    etherscan_api_key: Option<&str>,
) -> Result<FetchedAbi, FetchError> {
    eprintln!("[ABI-FETCHER] Attempting to fetch ABI for {} on {}/{}",
        contract_address, network, subnet);

    // Try Etherscan first (usually faster and more reliable)
    match fetch_abi_etherscan(contract_address, network, subnet, etherscan_api_key) {
        Ok(abi) => return Ok(abi),
        Err(FetchError::RateLimited { .. }) => {
            eprintln!("[ABI-FETCHER] Etherscan rate limited, trying Sourcify...");
        }
        Err(FetchError::ContractNotVerified { .. }) => {
            eprintln!("[ABI-FETCHER] Contract not verified on Etherscan, trying Sourcify...");
        }
        Err(e) => {
            eprintln!("[ABI-FETCHER] Etherscan error: {}, trying Sourcify...", e);
        }
    }

    // Fallback to Sourcify
    fetch_abi_sourcify(contract_address, network, subnet)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_etherscan_url() {
        assert_eq!(
            get_etherscan_url("ethereum", "mainnet"),
            Some("https://api.etherscan.io/api".to_string())
        );
        assert_eq!(
            get_etherscan_url("polygon", "mainnet"),
            Some("https://api.polygonscan.com/api".to_string())
        );
        assert_eq!(
            get_etherscan_url("unknown", "testnet"),
            None
        );
    }

    #[test]
    fn test_get_sourcify_chain_id() {
        assert_eq!(get_sourcify_chain_id("ethereum", "mainnet"), Some("1"));
        assert_eq!(get_sourcify_chain_id("polygon", "mainnet"), Some("137"));
        assert_eq!(get_sourcify_chain_id("unknown", "testnet"), None);
    }
}
