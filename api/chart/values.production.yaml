# Production values for ekko-api
replicaCount: 3

image:
  repository: ${API_IMAGE_REPOSITORY}
  tag: ${API_IMAGE_TAG:-latest}
  pullPolicy: ${API_PULL_POLICY:-Always}

imagePullSecrets:
  - name: ${DOCKER_REGISTRY_SECRET:-gitlab-registry}

service:
  type: ClusterIP
  port: 8000
  targetPort: 8000

ingress:
  enabled: true
  className: ${API_INGRESS_CLASS:-nginx}
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/rate-limit: "100"
  hosts:
    - host: ${API_HOST}
      paths:
        - path: /
          pathType: Prefix
  tls:
    - hosts:
        - ${API_HOST}
      secretName: ekko-api-tls-prod

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Django Configuration
django:
  secretKey: ""  # Injected from secrets
  debug: "False"
  allowedHosts: "api.ekko.zone,*.ekko.zone"
  settingsModule: ekko_api.settings.production

# CORS / CSRF Configuration (mapped into env vars by chart template)
development:
  corsAllowAll: "false"
  corsAllowedOrigins: ${CORS_ALLOWED_ORIGINS}
  csrfTrustedOrigins: ${CSRF_TRUSTED_ORIGINS:-https://app.ekko.zone}

# Database Configuration
postgresql:
  host: ${POSTGRES_HOST}
  port: ${POSTGRES_PORT}
  database: ${POSTGRES_DB}
  username: ${POSTGRES_USER}
  password: ""  # Injected from secrets
  sslMode: require
  poolSize: 20

database:
  url: ${DATABASE_URL}

# Redis Configuration
redis:
  host: ${REDIS_HOST}
  port: ${REDIS_PORT}
  password: ""  # Injected from secrets
  url: ${REDIS_URL}
  maxConnections: 100

# NATS Configuration
nats:
  url: ${NATS_URL}
  clusterId: ${NATS_CLUSTER_ID}
  clientId: ${NATS_CLIENT_ID}
  tlsEnabled: true

# WebAuthn Configuration
webauthn:
  rpId: ${WEBAUTHN_RP_ID}
  rpName: ${WEBAUTHN_RP_NAME}
  origin: ${WEBAUTHN_ORIGIN}

# JWT Configuration
jwt:
  accessTokenLifetimeMinutes: 60
  refreshTokenLifetimeMinutes: 10080  # 7 days
  secretKey: ""  # Injected from secrets

# Email Configuration
email:
  host: ""  # Injected from secrets
  port: 587
  useTls: true
  user: ""  # Injected from secrets
  password: ""  # Injected from secrets
  fromEmail: noreply@ekko.zone

# Firebase Configuration
firebase:
  enabled: true
  serviceAccountKey: '${FIREBASE_SERVICE_ACCOUNT_KEY}'
  projectId: ${FIREBASE_PROJECT_ID}
  authDomain: ${FIREBASE_AUTH_DOMAIN}
  webApiKey: ${FIREBASE_WEB_API_KEY}

# External Services
externalServices:
  huggingfaceApiKey: ""  # Injected from secrets
  huggingfaceEndpoint: https://api-inference.huggingface.co
  geminiApiKey: ""  # Injected from secrets
  geminiModel: ""  # Injected from secrets

# NLP Runtime Configuration (Django settings surface)
nlp:
  enabled: "true"
  requireDspy: "true"
  fallbackOnDspyFailure: "false"
  timeoutSeconds: "30"
  temperature: "0.1"
  maxTokens: "4096"
  maxRetries: "3"
  supportedNetworks: "ETH:mainnet,AVAX:mainnet"

nlpBootstrap:
  enabled: "true"
  pipelineId: "dspy_plan_compiler_v1"
  pipelineVersion: "v1-prod"
  examplesFile: "test-results/nlp_curated_demos_seed_v1.json"
  setActive: "true"

# Health Checks
healthcheck:
  enabled: true
  path: /health/
  headers:
    - name: Host
      value: ${API_HOST}
    - name: X-Forwarded-Proto
      value: https
  livenessProbe:
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3
  readinessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1

# Migrations
migrations:
  enabled: true
  command: ["python", "manage.py", "migrate", "--noinput"]

# Pod Security Context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# Container Security Context
securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000
  allowPrivilegeEscalation: false

# Node Selector for production nodes
nodeSelector:
  node-role.kubernetes.io/production: "true"

# Pod Anti-Affinity for high availability
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - ekko-api
        topologyKey: kubernetes.io/hostname

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
