package fetchers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"

	ekkoCommon "github.com/web3ekko/ekko-ce/pipeline/pkg/common"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/web3ekko/ekko-ce/pipeline/pkg/blockchain"
	"github.com/web3ekko/ekko-ce/pipeline/pkg/decoder"
	"github.com/web3ekko/ekko-ce/pipeline/pkg/testutils"
)

var (
	// Package-level variables for shared resources
	testCtx context.Context
)

// TestMain runs once before all tests in this package
func TestMain(m *testing.M) {
	// Initialize context
	testCtx = context.Background()

	// Run all tests
	code := m.Run()

	// Cleanup after all tests are done
	testutils.CleanupTestEnvironment()

	// Return the test status code
	os.Exit(code)
}

// stringPtr is a helper function to get a pointer to a string.
func stringPtr(s string) *string {
	return &s
}

// Using shared test environment from testutils package instead of per-test containers

// mockRPCServer is a helper to create an httptest.Server that mimics a JSON-RPC endpoint.
func mockRPCServer(_ *testing.T, handler http.HandlerFunc) *httptest.Server {
	return httptest.NewServer(handler)
}

func TestFetchFullBlock_SuccessByHash(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	// We use this hash in the request, but the go-ethereum client will compute its own hash based on block contents
	blockHash := "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
	// This is the actual hash generated by go-ethereum based on the block contents
	computedBlockHash := "0x8775f0c5305fe13de06b52226cac8a38c7b51ef6d89e6b13d0172ed334adfe77"
	
	expectedBlock := &blockchain.Block{
		Hash:       computedBlockHash, // Use the hash that will be computed by go-ethereum
		Number:     "0x1", // Shortened
		ParentHash: "0x0000000000000000000000000000000000000000000000000000000000000000", // Zero hash
		Sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", // Standard empty uncles hash
		StateRoot:  "0x0000000000000000000000000000000000000000000000000000000000000000", // Zero hash
		TransactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", // Hash of empty transactions
		ReceiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", // Hash of empty receipts
		LogsBloom:  "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", // Empty bloom filter
		Difficulty: "0x0",
		GasLimit:   "0x1000000", // Default gas limit
		GasUsed:    "0x0", // No gas used
		ExtraData:  "0x", // Empty extra data
		Timestamp:  "0x2", // Shortened
		Transactions: []blockchain.Transaction{}, // Simplified to empty slice
	}

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		var req blockchain.JSONRPCRequest
		err := json.NewDecoder(r.Body).Decode(&req)
		require.NoError(t, err, "Failed to decode request in mock server")

		assert.Equal(t, "eth_getBlockByHash", req.Method)
		require.Len(t, req.Params, 2, "Expected 2 params for eth_getBlockByHash")
		assert.Equal(t, blockHash, req.Params[0])
		assert.Equal(t, true, req.Params[1])

		resp := blockchain.JSONRPCResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Result:  expectedBlock, // Directly use the block struct, JSON marshaling handles it
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)
	})
	defer server.Close()

	config := ekkoCommon.NodeConfig{
		VMType:  "evm",
		Network: "testnet",
		// No need to specify HttpURL or WssURL here as they're not used directly
	}

	var bfRedisClient decoder.RedisClient = redisC
	if config.VMType != "evm" { // NewBlockFetcher only expects redis client for EVM
		bfRedisClient = nil
	}
	nodeCfg := ekkoCommon.NodeConfig{
		ID:      fmt.Sprintf("test-node-%s-%s", config.VMType, config.Network),
		VMType:  config.VMType,
		Network: config.Network,
		Subnet:  "test-subnet",
		HttpURL: server.URL, // Used by ethClient if VMType is EVM
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.NoError(t, err, "NewBlockFetcher failed")

	ctx := context.Background()
	block, err := bf.fetchFullBlock(ctx, blockHash)

	require.NoError(t, err, "fetchFullBlock returned an error")
	require.NotNil(t, block, "fetchFullBlock returned a nil block")
	assert.Equal(t, expectedBlock.Hash, block.Hash)
	assert.Equal(t, expectedBlock.Number, block.Number)
	assert.Equal(t, expectedBlock.ParentHash, block.ParentHash)
	assert.Equal(t, expectedBlock.Timestamp, block.Timestamp)
	assert.Equal(t, len(expectedBlock.Transactions), len(block.Transactions))
	if len(block.Transactions) > 0 {
		assert.Equal(t, expectedBlock.Transactions[0].Hash, block.Transactions[0].Hash)
	}
}

func TestFetchFullBlock_SuccessByNumber(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	blockNumberStr := "0x1b4"
	// blockNumberHex := "0x1b4" // Removed as it's no longer used
	// Use the actual hash that's being returned from the go-ethereum client
	expectedBlockHash := "0x8775f0c5305fe13de06b52226cac8a38c7b51ef6d89e6b13d0172ed334adfe77"

	expectedBlock := &blockchain.Block{
		Hash:       expectedBlockHash,
		Number:     "0x1", // Shortened
		ParentHash: "0x0000000000000000000000000000000000000000000000000000000000000000", // Zero hash
		Sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", // Standard empty uncles hash
		StateRoot:  "0x0000000000000000000000000000000000000000000000000000000000000000", // Zero hash
		TransactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", // Hash of empty transactions
		ReceiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", // Hash of empty receipts
		LogsBloom:  "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", // Empty bloom filter
		Difficulty: "0x0",
		GasLimit:   "0x1000000", // Default gas limit
		GasUsed:    "0x0", // No gas used
		ExtraData:  "0x", // Empty extra data
		Timestamp:  "0x2", // Shortened
		Transactions: []blockchain.Transaction{}, // Simplified to empty slice
	}

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		var req blockchain.JSONRPCRequest
		err := json.NewDecoder(r.Body).Decode(&req)
		require.NoError(t, err)

		assert.Equal(t, "eth_getBlockByNumber", req.Method)
		require.Len(t, req.Params, 2)
		assert.Equal(t, blockNumberStr, req.Params[0])
		assert.Equal(t, true, req.Params[1])

		resp := blockchain.JSONRPCResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Result:  expectedBlock,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)
	})
	defer server.Close()

	config := ekkoCommon.NodeConfig{VMType: "evm", Network: "testnet"}

	var bfRedisClient decoder.RedisClient = redisC
	if config.VMType != "evm" { // NewBlockFetcher only expects redis client for EVM
		bfRedisClient = nil
	}
	nodeCfg := ekkoCommon.NodeConfig{
		ID:      fmt.Sprintf("test-node-%s-%s", config.VMType, config.Network),
		VMType:  config.VMType,
		Network: config.Network,
		Subnet:  "test-subnet",
		HttpURL: server.URL,
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.NoError(t, err)

	ctx := context.Background()
	block, err := bf.fetchFullBlock(ctx, blockNumberStr)

	require.NoError(t, err)
	require.NotNil(t, block)
	assert.Equal(t, expectedBlock.Hash, block.Hash)
	assert.Equal(t, expectedBlock.Number, block.Number)
	assert.Equal(t, expectedBlock.ParentHash, block.ParentHash)
	assert.Equal(t, expectedBlock.Timestamp, block.Timestamp)
	assert.Equal(t, len(expectedBlock.Transactions), len(block.Transactions))
	if len(block.Transactions) > 0 {
		assert.Equal(t, expectedBlock.Transactions[0].Hash, block.Transactions[0].Hash)
	}
}

func TestFetchFullBlock_BlockNotFound(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	blockHash := "0xdeadbeefcafebabe000000000000000000000000000000000000000000000000"

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		var req blockchain.JSONRPCRequest
		err := json.NewDecoder(r.Body).Decode(&req)
		require.NoError(t, err)

		resp := blockchain.JSONRPCResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Result:  nil, // Block not found
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)
	})
	defer server.Close()

	nodeCfg := ekkoCommon.NodeConfig{
		ID:      "test-node-evm-testnet-blocknotfound",
		VMType:  "evm",
		Network: "testnet",
		Subnet:  "test-subnet",
		HttpURL: server.URL,
	}

	var bfRedisClient decoder.RedisClient = redisC
	if nodeCfg.VMType != "evm" { // Use nodeCfg
		bfRedisClient = nil
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Pass the full nodeCfg, Added true
	require.NoError(t, err)

	ctx := context.Background()
	block, err := bf.fetchFullBlock(ctx, blockHash) // server.URL is not passed here

	require.NoError(t, err, "Expected no error when block is not found (nil result)")
	require.Nil(t, block, "Expected nil block when not found")
}

func TestFetchFullBlock_RPCError(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	blockHash := "0x123"
	rpcErr := &struct { Code int `json:"code"`; Message string `json:"message"` }{Code: -32000, Message: "Server error"}

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		var req blockchain.JSONRPCRequest
		err := json.NewDecoder(r.Body).Decode(&req)
		require.NoError(t, err)

		resp := blockchain.JSONRPCResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Error:   rpcErr,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(resp)
	})
	defer server.Close()

	nodeCfg := ekkoCommon.NodeConfig{
		ID:      "test-node-evm-testnet-rpcerror",
		VMType:  "evm",
		Network: "testnet",
		Subnet:  "test-subnet",
		HttpURL: server.URL,
	}

	var bfRedisClient decoder.RedisClient = redisC
	if nodeCfg.VMType != "evm" { // Use nodeCfg
		bfRedisClient = nil
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Pass the full nodeCfg, Added true
	require.NoError(t, err)

	ctx := context.Background()
	block, err := bf.fetchFullBlock(ctx, blockHash) // server.URL is not passed here

	require.Error(t, err, "Expected an error due to RPC error")
	assert.Nil(t, block, "Expected nil block on RPC error")
	assert.Contains(t, err.Error(), rpcErr.Message, "Error message should contain RPC error message")
}

func TestFetchFullBlock_HTTPError(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	blockHash := "0x456"

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, "Internal Server Error")
	})
	defer server.Close()

	nodeCfg := ekkoCommon.NodeConfig{
		ID:      "test-node-evm-testnet-httperror",
		VMType:  "evm",
		Network: "testnet",
		Subnet:  "test-subnet",
		HttpURL: server.URL,
	}

	var bfRedisClient decoder.RedisClient = redisC
	if nodeCfg.VMType != "evm" { // Use nodeCfg
		bfRedisClient = nil
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Pass the full nodeCfg, Added true
	require.NoError(t, err)

	ctx := context.Background()
	block, err := bf.fetchFullBlock(ctx, blockHash) // server.URL is not passed here

	require.Error(t, err, "Expected an error due to HTTP error")
	assert.Nil(t, block, "Expected nil block on HTTP error")
	assert.Contains(t, err.Error(), "failed to fetch block 0x456: 500 Internal Server Error", "Error message mismatch")
}

func TestFetchFullBlock_InvalidIdentifier(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	config := ekkoCommon.NodeConfig{VMType: "evm", Network: "testnet", HttpURL: "http://localhost:1234"}

	var bfRedisClient decoder.RedisClient = redisC
	if config.VMType != "evm" { // NewBlockFetcher only expects redis client for EVM
		bfRedisClient = nil
	}
	nodeCfg := ekkoCommon.NodeConfig{
		ID:      fmt.Sprintf("test-node-%s-%s", config.VMType, config.Network),
		VMType:  config.VMType,
		Network: config.Network,
		Subnet:  "test-subnet",
		HttpURL: config.HttpURL, // This test case might specifically use config.HttpURL
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.NoError(t, err)

	ctx := context.Background()
	_, err = bf.fetchFullBlock(ctx, "not_a_hash_or_number")
	require.Error(t, err, "Expected error for invalid block identifier")
	assert.Contains(t, err.Error(), "invalid blockIdentifier format: 'not_a_hash_or_number'. Expected 0x-prefixed hash or number")
}

func TestFetchFullBlock_NonEVMType(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	config := ekkoCommon.NodeConfig{VMType: "solana", Network: "devnet", HttpURL: "http://localhost:1234"}

	var bfRedisClient decoder.RedisClient = redisC
	if config.VMType != "evm" { // NewBlockFetcher only expects redis client for EVM
		bfRedisClient = nil
	}
	nodeCfg := ekkoCommon.NodeConfig{
		ID:      fmt.Sprintf("test-node-%s-%s", config.VMType, config.Network),
		VMType:  config.VMType,       // This test is specifically for non-EVM
		Network: config.Network,
		Subnet:  "test-subnet",
		HttpURL: config.HttpURL, // For non-EVM, ethClient won't be initialized, URL doesn't matter for ethClient
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.NoError(t, err)

	ctx := context.Background()
	_, err = bf.fetchFullBlock(ctx, "some_identifier")
	require.Error(t, err, "Expected error for non-EVM vmType")
	assert.Contains(t, err.Error(), "fetchFullBlock: not an EVM fetcher or ethClient not initialized for devnet-test-subnet-solana")
}

func TestFetchFullBlock_EmptyHTTPURL(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	config := ekkoCommon.NodeConfig{VMType: "evm", Network: "testnet", HttpURL: ""} // Empty URL

	var bfRedisClient decoder.RedisClient = redisC
	if config.VMType != "evm" { // NewBlockFetcher only expects redis client for EVM
		bfRedisClient = nil
	}
	nodeCfg := ekkoCommon.NodeConfig{
		ID:      fmt.Sprintf("test-node-%s-%s", config.VMType, config.Network),
		VMType:  config.VMType,
		Network: config.Network,
		Subnet:  "test-subnet",
		HttpURL: "", // Test specifically for empty HttpURL
	}
	_, err = NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.Error(t, err, "Expected error from NewBlockFetcher due to empty HttpURL")
	assert.Contains(t, err.Error(), "HttpURL is required for EVM BlockFetcher (testnet-test-subnet-evm) but was empty")
	// bf would be nil here, so no call to bf.fetchFullBlock
}

func TestFetchFullBlock_MalformedJSONResponse(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	blockHash := "0x789"

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		fmt.Fprintln(w, "{not_valid_json]")
	})
	defer server.Close()

	nodeCfg := ekkoCommon.NodeConfig{
		ID:      "test-node-evm-testnet-malformedjsonresponse",
		VMType:  "evm",
		Network: "testnet",
		Subnet:  "test-subnet",
		HttpURL: server.URL,
	}

	var bfRedisClient decoder.RedisClient = redisC
	if nodeCfg.VMType != "evm" { 
		bfRedisClient = nil
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.NoError(t, err)

	ctx := context.Background()
	block, err := bf.fetchFullBlock(ctx, blockHash)

	require.Error(t, err, "Expected an error due to malformed JSON response")
	assert.Nil(t, block, "Expected nil block on malformed JSON response")
	assert.Contains(t, err.Error(), "invalid character 'n' looking for beginning of object key string")
}

func TestFetchFullBlock_Timeout(t *testing.T) {
	// Get shared environment
	redisC, natsC, js, err := testutils.GetTestEnvironment(testCtx)
	require.NoError(t, err, "Failed to get test environment")
	
	// Create test-specific KV store
	kv, err := testutils.GetTestKeyValueStore(js, t.Name())
	require.NoError(t, err, "Failed to create KV store")
	
	blockHash := "0xabc"

	server := mockRPCServer(t, func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(200 * time.Millisecond) // Sleep longer than client timeout
		w.WriteHeader(http.StatusOK)
	})
	defer server.Close()

	nodeCfg := ekkoCommon.NodeConfig{
		ID:      "test-node-evm-testnet-timeout",
		VMType:  "evm",
		Network: "testnet",
		Subnet:  "test-subnet",
		HttpURL: server.URL,
	}

	var bfRedisClient decoder.RedisClient = redisC
	if nodeCfg.VMType != "evm" { 
		bfRedisClient = nil
	}
	bf, err := NewBlockFetcher(nodeCfg, natsC, kv, bfRedisClient, true) // Added true for filterWalletsEnabled
	require.NoError(t, err)

	// Temporarily modify client timeout for this specific test case in fetchFullBlock
	// This is tricky because the client is created inside fetchFullBlock.
	// For a real scenario, client might be part of BlockFetcher struct or passed in.
	// Here, we rely on the default 15s timeout in fetchFullBlock being much larger
	// than our artificial delay. To properly test client-side timeout, we'd need to
	// make the HTTP client configurable or use a shorter timeout in the test setup.

	// The current fetchFullBlock has a hardcoded 15s timeout.
	// We can test a server-side timeout by making the server respond very slowly.
	// If the client's timeout (15s) is hit, it should return a context deadline exceeded error.

	// Let's create a context with a shorter timeout for the test itself
	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond) // Shorter than server sleep
	defer cancel()

	block, err := bf.fetchFullBlock(ctx, blockHash)

	require.Error(t, err, "Expected an error due to timeout")
	assert.Nil(t, block, "Expected nil block on timeout")
	// Check if the error is a context deadline exceeded error
	// This can manifest in different ways depending on the HTTP client and OS.
	// Often it includes "context deadline exceeded" or "Client.Timeout exceeded".
	assert.True(t, strings.Contains(err.Error(), "context deadline exceeded") || strings.Contains(err.Error(), "Client.Timeout exceeded"),
		"Error message should indicate a timeout: %v", err)
}
